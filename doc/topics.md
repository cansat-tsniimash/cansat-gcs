# Шина сообщений GCS

Шина наземной станции построена на ZMQ. Каждый абонент шины имеет два сокета - один PUB, другой SUB. Реквизты для соединений сокетов передаются через переменные окружения ITS_GBUS_PUB_ENDPOINT и ITS_GBUS_SUB_ENDPOINT. Все приложения вызывают `zmq_connect(...)` для этих эндпиоинтах на своих сокетах.

Все сообщения состоят минимум из двух частей (zmq multipart). Первая часть - это просто строка, которая показывает топик сообщения на шине. Дальше идет одна или несколько частей собственно сообщения.

В метаданных всех сообщений хранится время его формирования в стандартном формате time_s, time_us - целые части секунд POSIX таймштампа и дробные (микросекунды)


## Топики и сообщения

### Сообщения радио тракта

Эта группа сообщений связана непосредственно с радиоканалом. Они показывают состояние радиоканала и данные, которые по этому каналу ходят в наиболее примитивной форме.


#### radio.uplink_frame

Радио-сервер подписывается на этот топик и ожидает получать в него фреймы, которые будет отправлены по радио-каналу наверх. Не предполагается какой-либо очереди на этом топике и в аплинк пойдет самый свежий фрейм доступный на данный момент. Чтобы обеспечить управление потоком - отправителю данных следует смотреть на сообщения топика `radio.uplink_state`.

**Структура**

1. Топик;
2. Метаданные аплинк фрейма;
3. Сам аплинк фрейм.

Метаданные это JSON. Содержит одно поле - целое число, которое уникально идентифицирует передаваемый фрейм. При помощи этого числа можно узнавать передаваемый фрейм в сообщение `radio.uplink_state`. Число 64 битное и значение 0 - запрещено, так как призвано обозначать отсутствие фрейма в том или ином буфере

Схема: 
```json
{
	"type": "object",
	"properties": {
		"cookie": {
			"type": "integer",
			"minimum": 1
		}
	}
}
```

Пример:
```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"cookie": 10
}
```

Сам фрейм это простой бинарный массив байт длины не более чем условлено в радио-тракте. Все лишние байты будут отброшены, недобор будет дополнен нулями.

**Условия генерации**

Такое сообщение формируется кем-либо, кто хочет отправить фрейм по радио-каналу когда он захочет его отправить. Предполагается, что в системе такое _существо_ должно быть одно и что это будет USLP-стек


#### radio.uplink_state

Состояние _передаточных_ буферов сервера радио и самого радио.

**Структура** 

1. Топик;
2. Состояние передаточных буферов.

Состояние передаточных буферов - это JSON, содержащий 4 поля. Каждое поле содержит номер cookie, который передаются вместе с соответствующим фреймом. Поля показывают 4 _буфера_ или _состояния_.

Первое поле - _ожидает отправки_. Это поле содержит cookie номер фрейма, который ожидает очереди для отправки по радио-каналу. Если сейчас нет фрейма ожидающего отправки - поле имеет значение `null`.

Второе поле - _отправляется_. Это поле содержит cookie номер фрейма, который сейчас отправляется. Если сейчас не отправляется никакой фрейм - поле имеет значение `null`.

Третье поле - _отправлено_. Это поле содержит cookie номер фрейма, который был успешно отправлен в эфир. Поле инициализируется значением `null`, но не очищается а лишь обновляется при передаче очередного фрейма.

Четвертое поле - _отброшено_. Это поле содержит cookie номер фрейма, который не был отправлен, а был отброшен по той или иной причине. Та же. как и поле _отправлено_ инициализуется значением `null`, но затем не очищается, а лишь обновлется.

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"cookie_in_wait": {
			"type": "integer",
			"minimum": 1
		},
		"cookie_in_progress": {
			"type": "integer",
			"minimum": 1
		},
		"cookie_sent": {
			"type": "integer",
			"minimum": 1
		},
		"cookie_dropped": {
			"type": "integer",
			"minimum": 1
		}
	}
}

```

Пример:

```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"cookie_in_wait": 0,
	"cookie_in_progress": 3,
	"cookie_sent": 1,
	"cookie_dropped": 2
}

```

**Условия генерации**

Сообщение `radio.uplink_state` публикуется на шину при изменении значения какого-либо из его полей или же с определенным периодом (около секунды) в случае, если изменения не произошло. Публикует эти сообщения радио-сервер и предполагается, что в системе он такой один.


#### radio.downlink_frame

Радио-сервер бросает в этот топик сообщения с полученными по радио-каналу фреймами. 

**Структура**

1. Топик;
3. Метаданные фрейма;
2. Фрейм.

Метаданные фрейма это JSON. Содержит поле - флаг валидности контрольной суммы фрейма. Либо `true` если контрольная сумма сошлась, либо `false`, если не сошлась. Если вдруг контрольная сумма отключена и не проверяется - имеет значение `null`. Так же содержит некий cookie номер, который уникально идентифицирует этот фрейм. В этом же сообщении есть параметры качества сигнала с которым был принят этот фрейм и номер фрейма в радио канале (номер с которым его пульнул в эфир БКУ)

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"checksum_valid": {
			"type": ["boolean", "null"]
		},
		"cookie": {
			"type": "integer",
			"minimum": 1
		},
		"frame_no": {
			"type": "integer",
			"minimum": 0, "maximum": 65535
		},
		"rssi_pkt": {
			"type": "integer"
		},
		"snr_pkt": {
			"type": "integer"
		},
		"rssi_signal": {
			"type": "integer"
		}
	}
}
```

Пример:
```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"checksum_valid": true,
	"cookie": 42,
	"rssi_pkt": -2,
	"snr_pkt": 7, 
	"rssi_signal": -3
}
```

Фрейм это массив байт, которые прям как пришли так и есть.

**Условия генерации**

Сообщение с этим топиком публикуется радио-сервером, когда он успешно завершает RX операцию не по таймауту.


#### radio.rssi_instant

Это сообщение содержит текущее значение соотношения сигнал шум, которое ощущает радио в режиме RX

**Структура**

1. Топик;
2. RSSI значение.

RSSI значение передается JSON объектом, содержащим всего одно поле: `rssi`. Это мощность принимаемого сигнала (в dBm?). Строго неположительное число.

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"rssi": {
			"type": "integer"
		}
	}
}
```

Пример:
```json
{
	"time_s": 1624224857,
	"time_us": 428526,
	"rssi": -1
}
```

**Условия генерации**

С некоторых маленьким (около секунды а то и меньше) периодом все время, пока радио находится в RX режиме (а оно в нем находится часто)


#### radio.rssi_packet

Это сообщение содержит комплект значений сигнал шум, которые посчитало радио во время приёма очередного фрейма.

**Структура**

Сообщение состоит из двух частей:

1. Топик;
2. Значения RSSI.

Значения RSSI передаются в виде JSONа аж с тремя полями в каждом из которых свой аттрибут показывающий качество приёма. К сожалению не очень понятно что они значат :c. Так же в этом же сообщение хранится cookie пакета, которому соответствуют эти значения.

Схема:
```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		"cookie": {
			"type": "integer",
			"minimum": 1
		},
		"rssi_pkt": {
			"type": "integer"
		},
		"snr_pkt": {
			"type": "integer"
		},
		"rssi_signal": {
			"type": "integer"
		}
	}
}
```

Пример:
```json
{
    "time_s": 1624224858,
    "time_us": 439454,
    "checksum_valid": true,
    "cookie": 28,
    "rssi_pkt": 0,
    "snr_pkt": 13,
    "rssi_signal": 0
}
```

**Условия генерации**

Вместе с получаемым пакетом.


#### radio.stats

Это сообщение со статистикой радио и его состоянием в целом.

**Структура**

Сообщение состоит из двух частей:
1. Топик
2. Собстсвенно статистика и состояние

Состяние передается в виде джсона с целой кучей полей, названия которых говорят сами за себя.

Схема:

```json
{
	"type": "object",
	"properties": {
		"time_s": { "type:" "integer" },
		"time_us": { "type:" "integer" },
		
		// Количество полученных пакетов по мнению радио
		"pkt_received": { "type": "integer", "minimum": 0, "maximum": 65535 },
		// Ошибок контрольных сумм в телах полученных пакетах по мнению радио
		"crc_errors": { "type": "integer", "minimum": 0, "maximum": 65535 },
		// Ошибок контрольных сумм заголовков пакетов по мнению радио
		"hdr_errors": { "type": "integer", "minimum": 0, "maximum": 65535 },

		// Дальше идет массив аппаратных ошибок радио
		"error_rc64k_calib": { "type": "boolean" },
		"error_rc13m_calib": { "type": "boolean" },
		"error_pll_calib": { "type": "boolean" },
		"error_adc_calib": { "type": "boolean" },
		"error_img_calib": { "type": "boolean" },
		"error_xosc_calib": { "type": "boolean" },
		"error_pll_lock": { "type": "boolean" },
		"error_pa_ramp": { "type": "boolean" },

		// Сколько циклов RX накрутил сервер
		"srv_rx_done": { "type": "integer", "minimum": 0, "maximum": 4294967295},
		// сколько пакетов выгреб из радио сервер
		"srv_rx_frames": { "type": "integer", "minimum": 0, "maximum": 4294967295},
		// Сколько пакетов отправил в небо сервер
		"srv_tx_frames": { "type": "integer", "minimum": 0, "maximum": 4294967295},
		// текущая настройка мощности передатчика
		"current_pa_power": { "type": "integer", "minimum": -127, "maximum": 128 },
		// Запрошенное значение мощности для следующего фрейма
		"requested_pa_power": { "type": "integer", "minimum": -127, "maximum": 128 }
	}
}
```

Пример:
```json
{
	"pkt_received": 0,
	"crc_errors": 0,
	"hdr_errors": 0,
	"error_rc64k_calib": false,
	"error_rc13m_calib": false,
	"error_pll_calib": false,
	"error_adc_calib": false,
	"error_img_calib": false,
	"error_xosc_calib": true,
	"error_pll_lock": false,
	"error_pa_ramp": false,
	"srv_rx_done": 3,
	"srv_rx_frames": 0,
	"srv_tx_frames": 0,
	"current_pa_power": 22,
	"requested_pa_power": -1,
}
```

**Условия генерации**

Генерируются сервером-радио периодически.


#### radio.pa_power_request

Это сообщение является командой серверу радио на изменение мощности передатчика. Реальное изменение происходит при реконфигурации приёмника перед отправкой пакета наверх. И после этого его можно контроллировать в сообщении `radio.stats`.

Сообщение состоит из двух частей. Первая часть это топик. Вторая часть это жсон с единственным полем: `pa_power`.

Схема:

```json
{
	"type": "object",
	"properties": {
		// Запрашиваемая мощность
		"pa_power": { "type": "integer", "minimum": -127, "maximum": 128 }
	}
}
```

Пример:

```json
{ "pa_power": 22 }
```

### Сообщения антенной установки

Эта группа сообщений связана непосредственно с управлением антенной установкой. Они показывают ориентацию антенной установки и данные о состоянии ее внутренних параметров.

#### antenna.telemetry_packet

В этом топике публикуется телеметрия антенны.

**Структура**

1. Топик;
2. Метаданные;
3. Пакет.

Метаданных пока отсутствуют и это поле зарезервировано для будущих свершений и соответствия другим пакетам шины.

Сам пакет - набор байт, содержащий пакет MavLink ITS.


**Условия генерации**

Публикуется сервером антенны с частотой, зависящей от настроек.

#### antenna.command_packet

В этот топик публикуются пакеты, содержащие разного рода команды для антенной установки.

**Структура**

1. Топик;
2. Метаданные;
3. Пакет

Метаданных пока отсутствуют и это поле зарезервировано для будущих свершений и соответствия другим пакетам шины.

Сам пакет - набор байт, содержащий пакет MavLink ITS.


### Сообщение SDR приёмника

#### sdr.downlink_frame

Публикуется скриптом SDR приёмника. Содержит данные с борта в формате во многом аналогичным с сообщением под топиком `radio.downlink_frame`.

**Структура**

1. Топик;
2. Метаданные;
3. Пакет

Метаданные это джсон по схеме

```json
{
	"type": "object",
	"properties": {
		// Таймштамп события в секундах
		"time_s": { "type:" "integer" },
		// Таймштмап события в миллисекундах
		"time_us": { "type:" "integer" },
		// циклический номер события (с int64 периодом)
		"cookie": {
			"type": "integer",
			"minimum": 1
		},
		// Соотношение сигнал шум по мнениею gr-lora. Мнение у нее интересное
		"snr": {
			"type": "integer",
			"minimum": -255,
			"maximum": 255
		},
		// Номер пакета как он сообщен с борта
		"frame_no": {
			"type": "integer",
			"minimum": 0, "maximum": 65535
		},
		// Сырые байты TAP части lora-tap пакета от gr-lora
		"tap_bytes": {
			"type": "string"
		},
		// Сырые байты RSSI части lora-tap пакета от gr-lora
		"rssi_bytes": {
			"type": "string"
		},
		// Сырые байты crc части lora-tap пакета от gr-lora (не правильные :'()
		"crc_bytes": {
			"type": "integer"
		}
	}
}
```

### Сообщения USLP стека

Эта группа сообщений используется для взаимодействия с CCSDS USLP стеком

#### uslp.downlink_sdu.xx.yy.zz

Это сообщение публикуется USLP сервером при получении им какого либо SDU с борта.

**Структура**

Сообщение - это традиционный zmq мультипарт, состоящий из трех частей

1. Топик;
2. Метаданные;
3. Пакет

Топик - помимо фиксированной части содержит код канала, в котором получено сообщение. Так, для сообщения с аппарата номер 42, переданного по виртуальному каналу 10, по MAP каналу 20 топик будет вида `uslp.downlink_sdu.42.10.20`. Эти же цифры доступны в метаданных сообщения и USLP сервер обещает очень постараться, чтобы они совпадали.

Метаданные - это JSON по следующей схеме

```json
{
	"type": "object",
	"properties": {
		// Номер аппарата
		"sc_id": {
			"type": "integer"
		},
		// Номер виртуального канала по которому получена SDU
		"vchannel_id": {
			"type": "integer"
		},
		// Номер MAP канала, по которому получена SDU
		"map_id": {
			"type": "integer",
		},
		// Качество доставки SDU
		"qos": {
			"type": "string",
			"enum": [
				// Как получилось
				"expedited",
				// Мы очень старались (с "гарантированной"" доставкой)
				// (сейчас не реализовано)
				"sequence_controlled",
			]
		},
		// Флаги полученной SDU
		"flags": {
			"type": "array",
			"items": {
				"type": "string",
				"enum": [
					"mapa",		// Полученный SDU имеет тип mapa
					"mapp",		// Полученный SDU имеет тип mapp
					"stray",	// Полученный SDU не синхронизирован
								// (это какой-то кусок какого-то пакета,
								// но мы не знаем какого и из какой части пакета кусок)
					"incomplete",	// Полученный SDU - это начало какого-то пакета. Конец потерялся
					"corrupted",	// Полученный SDU был выгребен
									// из фреймов с не правильной контрольной суммой
				]
			}
		}
	}
}
```

Пример:

```json
{
	"flags": [
		"mapp"
	],
	"map_id": 0,
	"qos": "expedited",
	"sc_id": 66,
	"vchannel_id": 0
}
```

Сам пакет это пакет CCSDS Space Packet Protocol (SPP) или CCSDS Encapsualtion Packet Protocol
(EPP) (сейчас реализовано только EPP).

У нас на борту определено два канала. Один для IP пакетов, второй для Mavlink телеметрии. Какой есть какой - спросите у Сергея или Василия.

**Условие генерации**

Генерируется USLP стеком, если он выцепил из фреймов телеметрии что-то, что считает нужным показать


#### uslp.uplink_sdu_request.xx.yy.zz

Эти сообщения - это запросы на передачу команд на борт через USLP стек. USLP сервер подписывается на них и по получению начинает с ними делать всякое. О том что с ними дальше происходит - USLP сервер сообщает отдельным сообщением.

**Структура**

Классический zmq мультипарт из трех частей

1. топик;
2. метаданные;
3. пакет.

Топик - помимо фиксированной части содержит код канала, которым нужно отправить сообщение. Так, для сообщения для аппарата номер 42, передаваемого по виртуальному каналу 10, по MAP каналу 20 топик следует делать вида `uslp.uplink_sdu_request.42.10.20`. Эти же цифры доступны и в метаданных и USLP сервер читает именно их. Но если наврать в топике - USLP сервер будет обижаться, поэтому так делать не стоит.

Метаданные - это JSON по схеме

```json
{
	"type": "object",
	"properties": {
		// Уникальная циферка, которая нужна для опознания этого SDU дальше
		// Сервер будет кидать разные сообщения о том, что с этим SDU происходит
		// и по этой циферке можно будет понимать о чем именно идет речь
		// Предполагается, что клиент для каждого своего SDU придумывает уникальную куку
		"cookie": {
			"type": "integer",
			"minimum": 0,
			"maximum": 18446744073709551615 // 2**64-1
		},
		// Номер аппарата к которому нужно передавать SDU
		"sc_id": {
			"type": "integer"
		},
		// Номер виртуального канала по которому нужно передавать SDU
		"vchannel_id": {
			"type": "integer"
		},
		// Номер MAP канала, по которому нужно передавать SDU
		"map_id": {
			"type": "integer",
		},
		// Требуемое качество доставки SDU
		"qos": {
			"type": "string",
			"enum": [
				// Как получится
				"expedited",
				// очень стараться (с гарантированной доставкой)
				// (сейчас не реализовано)
				"sequence_controlled",
			]
		}
	}
}
```

Пример:

```json
{
    "cookie": 0,
    "map_id": 0,
    "qos": "expedited",
    "sc_id": 66,
    "vchannel_id": 0
}
```

Сам пакет это пакет CCSDS Space Packet Protocol (SPP) или CCSDS Encapsualtion Packet Protocol
(EPP) (сейчас реализовано только EPP).

У нас на борту определено два канала. Один для IP пакетов, второй для Mavlink команд. Какой есть какой - спросите у Сергея или Василия.

**Условие генерации**

Генерируется клиентами USLP сервера, когда они что-то хотят отправить на борт

**Flow control**

Для каждого MAP канала в USLP стеке есть своя не лимитированная очередь на отправку. Поэтому если накидать 100500 сообщений для отправки, то есть шанс, что ждать отправки их всех придется ооочень долго. Способов отменить отправку (не перезапуская USLP стек) сейчас нет, поэтому будьте осторожны.


#### uslp.uplink_sdu_event.xx.yy.zz

Это сообщение публикуется USLP сервером, когда что-нибудь интересное происходит с SDU, отправку которой у него запросили. Отдельные SDU идентифицируются своими `cookie`, которые указываются в запросах на отправку SDU.

**Структура**

Классический zmq мультипарт из трех частей

1. топик;
2. метаданные;
3. пакет.

Топик - помимо фиксированной части содержит код канала, на котором происходит событие. Так, для сообщения для аппарата номер 42, передаваемого по виртуальному каналу 10, по MAP каналу 20 сервер склеит топик вида `uslp.uplink_sdu_event.42.10.20`. Эти же цифры доступны в метаданных сообщения и USLP сервер обещает очень постараться, чтобы они совпадали.

Метаданные - это JSON по схеме

```json
{
	"type": "object",
	"properties": {
		// Идентификатор передаваемой SDU (указывается клиентом в запросе)
		// Поскольку при передаче SDU может пилится на части - такое сообщение
		// публикуется для каждой из частей. Поэтому помимо самой куки
		// тут есть есть информация о том - о каком куске изначальной SDU идет речь
		"cookie": {
			"type": "object",
			"properties": {
				// та самая циферка, которую дал клиент при запросе на отправку
				"cookie": {
					"type": "integer",
					"minimum": 0,
					"maximum": 18446744073709551615 // 2**64-1
				},
				// Номер части SDU о которой идет речь.
				"part_no": {
					"type": "integer",
					"minimum": 0
				},
				// Эта часть SDU последняя? больше не будет?
				"is_final_part": {
					"type": "boolean"
				}
			}
		},
		// Номер аппарата к которому SDU передается
		"sc_id": {
			"type": "integer"
		},
		// Номер виртуального канала по которому SDU передается
		"vchannel_id": {
			"type": "integer"
		},
		// Номер MAP канала, по которому SDU передается
		"map_id": {
			"type": "integer",
		},
		// Собственно что произошло то!
		"event": {
			"type": "string",
			"enum": [
				// USLP серверу нравится SDU и он принял её в очередь на отправку
				"sdu_accepted",
				// USLP серверу не нравится SDU, он выкинул её в небытие и отправлена она не будет
				"sdu_rejected",
				// USLP сервер отправил очередной кусок SDU в радио сервер
				"sdu_sent_to_radio",
				// USLP сервер считает что очередной кусок SDU был выпущен в эфир
				"sdu_radated",
				// USLP сервер считает, что очередной кусок SDU в эфир выпустить не удалось
				"sdu_radiation_failed"
			]
		}
	}
}
```

**Условия генерации**

Вполне очевидны, для того, чтобы их писать отдельно.
